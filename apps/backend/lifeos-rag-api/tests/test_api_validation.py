import unittest
from datetime import datetime, timezone
import json
import tempfile
import os

from fastapi.testclient import TestClient
from main import app, get_event_store, get_event_processor, get_db
from auth import get_current_user
from schemas import Zettel, ZettelCreate, ZettelUpdate # Import new schemas

from event_sourcing.event_store import EventStore
from event_sourcing.event_processor import EventProcessor
from database import Base, StoredEvent, ZettelReadModel, User

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

class TestAPIValidation(unittest.TestCase):

    def setUp(self):
        # 1. Setup a temporary file-based SQLite database
        self.db_fd, self.db_path = tempfile.mkstemp()
        self.test_engine = create_engine(f"sqlite:///{self.db_path}")
        Base.metadata.create_all(self.test_engine) # Create all tables from the single Base
        TestSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.test_engine)

        self.test_event_store = EventStore(engine=self.test_engine)
        self.test_event_processor = EventProcessor(self.test_event_store, engine=self.test_engine)

        def override_get_event_store():
            return self.test_event_store

        def override_get_event_processor():
            return self.test_event_processor
        
        def override_get_db():
            db = TestSessionLocal()
            try:
                yield db
            finally:
                db.close()

        # Apply dependency overrides
        app.dependency_overrides[get_event_store] = override_get_event_store
        app.dependency_overrides[get_event_processor] = override_get_event_processor
        app.dependency_overrides[get_db] = override_get_db # Override main DB dependency
        # Mock authentication
        app.dependency_overrides[get_current_user] = lambda: "testuser"

        # Initialize TestClient AFTER dependency overrides
        self.client = TestClient(app)

        # Replay events to ensure clean state for EventProcessor
        self.test_event_processor.replay_events()
    
    def tearDown(self):
        app.dependency_overrides.clear() # Clear overrides after each test
        # Drop tables and dispose engines after each test
        Base.metadata.drop_all(bind=self.test_engine)
        self.test_engine.dispose()
        os.close(self.db_fd)
        os.unlink(self.db_path)

    def test_create_zettel_valid(self):
        valid_zettel_create_data = {
            "type": "zettel",
            "title": "Valid Zettel Title",
            "body": "This is a valid zettel body.",
            "links": [],
            "tags": [],
            "horizon": "vision",
            "contexts": []
        }
        response = self.client.post("/zettel/", json=valid_zettel_create_data)
        self.assertEqual(response.status_code, 201)
        self.assertIsNotNone(response.json()["id"]) # ID is now generated by API
        self.assertEqual(response.json()["title"], "Valid Zettel Title")
        self.assertEqual(response.json()["username"], "testuser")


    def test_create_zettel_missing_title(self):
        invalid_zettel_create_data = {
            "type": "zettel",
            "body": "This zettel is missing a title.",
            "links": [],
            "tags": [],
            "horizon": "none",
            "contexts": []
        }
        response = self.client.post("/zettel/", json=invalid_zettel_create_data)
        self.assertEqual(response.status_code, 422) # Unprocessable Entity

    def test_create_zettel_invalid_horizon(self):
        invalid_zettel_create_data = {
            "type": "zettel",
            "title": "Invalid Horizon",
            "body": "This zettel has an invalid horizon.",
            "links": [],
            "tags": [],
            "horizon": "invalid_value", # Invalid enum value
            "contexts": []
        }
        response = self.client.post("/zettel/", json=invalid_zettel_create_data)
        self.assertEqual(response.status_code, 422) # Unprocessable Entity

    def test_update_zettel_invalid_id_mismatch(self):
        # First, create a zettel
        initial_zettel_create_data = {
            "type": "zettel",
            "title": "Existing Zettel",
            "body": "Original body.",
            "links": [], "tags": [], "horizon": "vision", "contexts": []
        }
        create_response = self.client.post("/zettel/", json=initial_zettel_create_data)
        self.assertEqual(create_response.status_code, 201)
        existing_zettel_id = create_response.json()["id"]

        # Attempt to update with a mismatched ID
        zettel_update_data = {
            "id": "mismatched_id", # Mismatched ID
            "title": "Updated Title"
        }
        response = self.client.put(f"/zettel/{existing_zettel_id}", json=zettel_update_data)
        self.assertEqual(response.status_code, 400) # Bad Request
        self.assertEqual(response.json()["detail"], "Zettel ID in path and body do not match")

    def test_read_zettel_not_found(self):
        response = self.client.get("/zettel/non_existent_zettel")
        self.assertEqual(response.status_code, 404)
        self.assertEqual(response.json()["detail"], "Zettel not found")

    def test_delete_zettel_not_found(self):
        response = self.client.delete("/zettel/non_existent_zettel")
        self.assertEqual(response.status_code, 404)
        self.assertEqual(response.json()["detail"], "Zettel not found")

    def test_update_zettel_not_found(self):
        zettel_update_data = {
            "id": "non_existent_zettel",
            "title": "Non-existent Zettel Title"
        }
        response = self.client.put("/zettel/non_existent_zettel", json=zettel_update_data)
        self.assertEqual(response.status_code, 404)
        self.assertEqual(response.json()["detail"], "Zettel not found")
